---
title: Write a domain-specific language in javascript in a weekend
description: 
date: 2024-09-01
tags:
  - javascript
series: weekend-series
---

import { DSLNestingProps } from "~/components/javascript-dsl/DSLNestingProp"

**A domain-specific language(DSL) is a small language made for a specific purpose.** It's the opposite of general languages like: JavaScript, Python, Go, etc. which are designed to do *everything*.

Think of `SQL` or `HTML`. SQL is made to more easily query structured data, and HTML is made to more easily represent the structure of a document/website.

## Contents

## Why make your own DSL? 
Because it's _cool_. It's also much easier to do than making a general language. And it might even be a useful tool to be able to whip out in certain cases.

## Why in a weekend?
I really liked the approachable nature of [Ray tracing in one weekend](https://raytracing.github.io/). It condensed a complex subject into a project that can be finished in a few days.

This article will take less than that, a few hours to a day.

## What are we making?
We'll be making a DSL that lets us query JSON objects with a more readable syntax and quicker than with regular JS.

We'll start small, but by the end we'll be able to write:
```
scores
  score > 1000
  desc name.firstName
  grab name.lastName
```
instead of:
```js lang="js"
scores
  .filter(s => s.score > 1000)
  .sort((a,b) => -a.name.firstName.toLocalCompare(b.name.firstName))
  .map(s => s.name.lastName)
```

Let's call this language `jayson`.

## Overview

It's probably best to start a DSL by planning out how what exactly it will do and how that will be accomplished.

We'll do the opposite of that for this project. We'll start by implementing a super-basic version of the language, and build up more features on top of it as we go along.

Here's a short list of what you should figure out when you start your next DSL project:

<p class="h-1v"/>

1. Determine scope
    - What features are supported?
    - What features are explicitly _**not**_ supported?
2. Design the syntax
    - How will the DSL look like?
    - Does it have JS-style curly braces or significant whitespace like Python?
    - What are the _keywords_ we're supporting?
3. Implementation
    - Which language will it be implemented in? (also called the "host language")
    - How do we transform the DSL into host language instructions?
    - Will the DSL features require run-time functionality?


## From text to code

There's a very simple pipeline that all DSLs have to go through. The details can be complicated but at a high level it's always just `text -> code`.

You write some text somewhere, maybe a file, maybe a string. Some code then picks that up, extracts all of the information from the text and turns it into more code that does something.

The first step of building `jayson` is to set up that pipeline.

To keep things easy in the beginning, we'll be writing the jayson code directly as JS strings.


### What's our pipeline?
We need 2 things to get started: a JSON object to query, and jayson string.

Fire up your editor and create a `jayson.js` file:

```js lang="js" file="jayson.js"
const o = {
  name: "My cool object",
  isItCool: true,
}

const jayson = "grab name"
```

`o` will be our queryable object, and we'll store the code for the jayson language in the `jayson` variable.

`grab` is the first bit of functionality that we'll implement.

Given the keywork `grab` and a property name, it will select that property from the object.

So the code `grab name` should return `"My cool object"`.


In the same file, after the declarations, we'll create a function that can take the input and return the right output:
```js lang="js" file="jayson.js"
const o = {
  name: "My cool object",
  isItCool: true,
};
const jayson = "grab name";
const query = (obj, input) => {
  // logic will go here
}
query(o, jayson); // will return "My cool object"
```

### Parsing the jayson input
The query function should make sure that the jayson code is in the right format, and then extract the relevant information from it so that we can use it.
```js lang="js" file="jayson.js"
const query = (obj, input) => {
  const [keyword, property] = input.split(" ");
  if(keyword !== "grab") 
    throw Error("Invalid jayson syntax.");
  return obj[property];
}
```

Look at that, your first DSL! And it only took 5 lines of code.

If you run `console.log(query(o, jayson))` you should see  `"My cool object"` being logged.

Now try to replace the jayson string to grab the other property.

What happens if you do `grab someRandomProp`?

### Nested properties
Modify the query object so it has a nested property:
```js lang="js" file="jayson.js"
const o = {
  name: "My cool object",
  isItCool: true,
  metadata: {
    coolnessScore: 100,
  }
};
```
Running `grab metadata.coolnessScore` will return `undefined`.

The query function takes the whole of `metadata.coolnessScore` as one string and uses that as a proprty, which doesn't exist.

It should split the properties by '.' instead and do multiple nested queries
```js lang="js" file="jayson.js"
const query = (obj, input) => {
  const [keyword, property] = input.split(" ");
  if(keyword !== "grab") 
    throw Error("Invalid jayson syntax.");

  // Updated code
  const nested = property.split(".");

  let result = obj; // result starts out as the full object

  for (const property in nested) {
    // as we loop through the properties, first "metadata", then "coolnessScore",
    // we set the result as each nested query that we performed
    result = result[property];
  }
  return result;
}
```

The for loop is doing the heavy lifting for handling the nested props. Here it is explained visually:

<DSLNestingProps />

### Multiple properties
How do we grab multiple properties from one object? We can't. Not yet at least.

The next extension to the `grab` feature, is adjusting the syntax so that running `grab isItCool, metadata.coolnessScore` will return both values.

But grabbing 2 or more properties from an object will result in 2 values. JavaScript can't do multiple returns.

We'll have to wrap the 2 values in either an array or an object.

Either

`[true, 100]` or `{isItCool: true, coolnessScore: 100}`

The object wrapping is more readable so we'll go with that.

For consitency, we'll change the single property grab to return an object too.

`grab isItCool` will return `{isItCool: true}` instead of `true`.
.split(/, |,| /)

```js lang="js" file="jayson.js"
...
const query = (obj, input) => {
  ...error handling code omitted

  const properties = property.split(/, |,| /);
  let aggregate = {};

  for (const temp of properties) {
    const nested = temp.split(".");
    let result = obj;
    for (const property of nested) {
      result = result[property];
    }
    const lastProperty = nested.at(-1)
    aggregate[lastProperty] = result;
  }

  return aggregate;
}
query(o, "grab isItCool, metadata.coolnessScore")
```

There's been a few changes, here they are explained line by line:

<p class="mt-1v"/>

- const properties = property.split(/, |,| /); <br/>
